% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mape_negbinomial.R
\name{mape_negbinomial}
\alias{mape_negbinomial}
\title{mape_negbinomial}
\usage{
mape_negbinomial(
  df,
  r_prior,
  p_prior,
  M_prior,
  eta = 0.1,
  tol = 1e-04,
  maxIter = 10000,
  method = c("newton", "gdescent")
)
}
\arguments{
\item{df}{data.frame object, containing at least column named 'x' containing non-negative integer values.}

\item{r_prior}{positive numeric; recommended choose as if there was observed "prior sample" Y of size 'M_prior', where Y ~ nbinom(r_prior, p_prior).}

\item{p_prior}{numeric strictly greater than 0 and less than 1; recommended choose as if there was observed "prior sample" Y of size 'M_prior', where Y ~ nbinom(r_prior, p_prior).}

\item{M_prior}{positive numeric; recommended choose as if there was observed "prior sample" Y of size 'M_prior', where Y ~ nbinom(r_prior, p_prior).}

\item{eta}{positive numeric dampening parameter for Newton's method, gradient descent algorithm.}

\item{tol}{non-negative numeric tolerance parameter for exiting optimization algorithm.}

\item{maxIter}{positive integer setting maximum number of iterations for optimization algorithm.}

\item{method}{string controlling optimization method; default 'newton'.}
}
\value{
List object containing maximum a-posteriori estimates (MAPEs) of negative binomial distribution parameters r and p, assuming df$x ~ nbinom(r, p), and (r, p) ~ MVN(mu, Sigma).  (Please see DHBayes_Derivations.pdf on GitHub for how mu, Sigma relate to 'r_prior', 'p_prior', and 'M_prior' inputs.)
}
\description{
mape_negbinomial
}
\examples{
# Generate example data:
set.seed(31)
r = 4
p = 0.3

# Number of experiments, i.e. rows in df:
numexps = 10

# Filling df with pseudo data; note the requisite column 'x':
df = data.frame('x' = rnbinom(numexps, r, p))

# Generating maximum a posteriori estimate (MAPE) solution for r and p:
rp_fit = mape_negbinomial(df = df, r_prior = 2, p_prior = 0.5, M_prior = 1)

# Compare fitted values to known values:
cbind(c(r, p), c(rp_fit$r, rp_fit$p))
}
